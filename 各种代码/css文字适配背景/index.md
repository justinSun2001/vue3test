还记得 2017 年，我们响应朋友的邀约从高德离职出来创业的时候，遇到了一个相对来说有点特殊的需求，动态的文字有长有短，但是需要智能适配背景的颜色变成其 **对比色** 。大概效果如下：

仔细看会发现，哪怕**半个文字**存在于两个不同的背景色之间，这个文字也会被**分割**成两个颜色。

看到这样的需求，大多数人第一时间想到的是，文字元素有两个，是完全重叠的两层，一层是黑色，一层是白色，然后通过遮罩实现。没错，这样的确可以实现这样的效果，但是也会让 **DOM** 结构过于复杂。

于是，今天我就带领大家只用 **一个文字元素** ，使用**混合模式**实现这样的效果。那么我们就开始吧！

---

# 一、构建背景容器

我们就用**一个 div 元素**实现黑色边框，一半**黑色**一半 **白色** ，分割线还是**倾斜**的 **背景容器** 。

```html
<div><div>
```

**DOM** 结构尽可能的简约，所以就直接这样放一个 **div** 即可。核心是需要使用 **CSS** 控制其 **显示样式** 。

先不想那么多，我们先给容器一个**大小**和 **黑色边框** ，并设置**背景颜色**为 **白色** 。

```css
div {
  height: 500px;
  border: 5px solid #000;
  background: #fff;
}
```

很明显，现在只有一个框。

这个时候，我们需要让**背景**有一半为 **黑色** ，并且**黑色部分**构成一个 **直角梯形** 。自然会想到使用**该元素**的 **before** 或者 **after** 两个**伪元素**来实现。

既然要使用 **伪元素** ，大概率涉及到了**伪元素**的 **定位** ，那么我们先给 **div** 元素一个 **相对定位** 。

```css
div {
  position: relative;
  height: 500px;
  border: 5px solid #000;
  background: #fff;
}
```

小小知识点：

> * **position** 属性是控制元素**定位**的，**默认值**为  **static** 。
> * 若一个元素的 **position** 属性值为 **绝对定位（absolute）** ，即可通过  **top** 、**bottom** 两个属性控制该元素的 **竖直偏移** ，也可以通过  **right** 、**left** 两个属性控制该元素的 **水平偏移** 。
> * 若没有设置  **top** 、**bottom** 两个属性，则**竖直方向**的**偏移**和 **position** 的值为 **static** 显示的一样；若没有设置  **right** 、**left** 两个属性，则**水平方向**的**偏移**和 **position** 的值为 **static** 显示的一样。
> * 无论**水平方向**还是 **竖直方向** ，只要 **设置了偏移属性** ，那么就需要看**该元素**的**父元素**的 **position** 是什么值。若**父元素**的 **position** 不是  **static** ，那么就会以**该父元素**的**容器范围**为**基准**开始偏移；若**父元素**的 **position** 是  **static** ，那么就会无视**该父元素**的 **管理范围** ，继续向上寻找“爷爷”元素，直到找到 **position** 不是 **static** 的元素，或者直接以 **body** 元素为 **基准** 。

我曾经在** **[《【欧洲杯】用纯前端写一个滚动的足球（上）》](https://juejin.cn/post/7383561807178711040)这篇文章中讲解过如何使用**伪元素**写 **正五边形** 。现在我们需要使用 **before** 和 **after** 两个**伪元素**组成一个 **直角梯形** ，最简单的方式就是使用 **before** 写成一个 **矩形** ，然后使用 **after** 写成一个 **直角三角形** ，然后**拼接**在一起。

按照这样的思路，我们直接用 **CSS** 把这个**直角梯形**写出来：

```css
div::before,
div::after {
  position: absolute;
  top: 0;
  bottom: 0;
  display: block;
  content: "";
}
div::before {
  left: 0;
  width: 40%;
  background: #000;
}
div::after {
  left: 40%;
  width: 0;
  height: 0;
  border-top: 250px solid transparent;
  border-right: 100px solid transparent;
  border-bottom: 250px solid #000;
  border-left: 100px solid #000;
}
```

按照这样的结构设计：

我们得到如下结果：

这就是我们想要的背景容器。

---

# 二、放入文字

一般来说，直接在 **div** 中写入文字即可。考虑到对**鼠标悬停**存在**动画**效果，我们就在 **div** 中放一个 **h1** 标签。

```html
<div>
  <h1>实现文字智能适配背景</h1>
</div>
```

通过 **CSS** 控制文字的**位置**和 **大小** ：

```css
h1 {
  position: absolute;
  left: 40%;
  z-index: 1;
  font-size: 9rem;
}
```

> 设置了 **z-index** 属性，让其显示在 **div** 元素的**伪元素**的 **上方** 。

默认情况下，文字的颜色是黑色的：

设置文字颜色为白色：

```css
h1 {
  position: absolute;
  left: 40%;
  z-index: 1;
  font-size: 9rem;
  color: #fff;
}
```

显示效果如下：

为了看的更加清楚，我们给文字增加一个动画，让**鼠标进入**的时候，文字 **向左滑动** ，反之回到原位。

```css
h1 {
  position: absolute;
  left: 40%;
  z-index: 1;
  font-size: 9rem;
  color: #fff;
  transition: 0.5s;
}
div:hover > h1 {
  transform: translateX(-60%);
}
```

可以看到这样的效果：

这样，我们已经把文字插入到元素中了。但是，文字在白色部分是看不出来的，怎么办呢？掌声有请我们今天的主角的—— ***混合模式*** ！

---

# 三、混合模式

需要让文字智能适配背景的颜色，在黑色部分显示白色，在白色部分显示黑色，我们需要用到 **混合模式** 。

想要把**混合模式**完全搞懂，需要对**颜色**及其**三要素**有一定的了解。这里完全可以单独开一门课程进行讲解，今天涉及到了，就只能给大家做一个简单的介绍。

> * ***色调*** ，是**色彩**的 **首要特征** ，是区别各种不同色彩的**最准确**的 **标准** ，即各类色彩的 **相貌称谓** 。
> * ***饱和度*** ，又叫 **纯度** ，是指色彩的 **鲜艳程度** 。
> * ***明度*** ，也叫 **亮度** ，是眼睛对光源和物体表面的**明暗程度**的感觉，主要是由**光线强弱**决定的一种 **视觉经验** 。

相信大多数人第一次接触 **混合模式** ，是在 **Photoshop** 中。

在 **CSS** 中，**混合模式**是用于控制 **HTML** 的**元素间**的 **颜色混合模式** 。它允许某个 **HTML** 元素的**内容**与其**背后的背景**或**其他 HTML 元素内容**以**特定**的方式 **相互作用** ，从而实现**相对复杂**的 **叠加效果** ，从而提升页面的**视觉层次**与 **艺术感** 。

在 **CSS** 中，主要是 **background-blend-mode** 属性和 **mix-blend-mode** 两个属性来实现元素的 **混合模式** 。

> * ***background-blend-mode*** - 指定 **HTML** 元素的 **背景层** （包括 **背景颜色** 、**背景图片**等）之间的 **混合模式** 。
> * ***mix-blend-mode*** - 指定一个 **HTML** 元素的 **内容** （包括 **文字** 、**内嵌图像**等）与其下方 **HTML** 元素的 **混合模式** 。

**标准混合模式**有如下** ****16** 个：

* **Normal（默认）：**

> * 不进行特殊混合，**上层的 HTML 元素**直接盖住 **下层的 HTML 元素** ；
> * 这是**默认**的 **混合模式** ，相当于 **没有混合** 。

* **Multiply（正片叠底）：**

> * 将**上层 HTML 元素**中的**颜色**与**下层 HTML 元素**的**颜色**的**每一个分量**进行 **相乘** ，一般情况下，计算后的**结果颜色**比原本的 **颜色更暗** ；
> * 对于**上层 HTML 元素**中的**颜色**是**纯黑色**或**纯白色**的，混合后的结果将分别保持**下层 HTML 元素**的**颜色**不变或变为 **纯黑色** 。

* **Screen（滤色）：**

> * 类似于**两层幻灯片重叠**的效果，**上层 HTML 元素**的**颜色**与**下层 HTML 元素**的**颜色**的 **互补色相乘** ，然后 **取反** ；
> * 一般情况下，计算后的**结果颜色**比原本的 **颜色更亮** ；
> * 对于**上层 HTML 元素**中的**颜色**是**纯黑色**或**纯白色**的，混合后会使**下层 HTML 元素**的**颜色**不变或变为 **纯白色** 。

* **Overlay（叠加）：**

> * 结合了** ****Multiply** 和** ****Screen** 模式的特点；
> * 对于**下层 HTML 元素**的**颜色较暗**的区域，使用** ****Multiply** 模式；
> * 对于**下层 HTML 元素**的**颜色较亮**的区域，使用** ****Screen** 模式；
> * 这种模式可以 **增强对比度** 。

* **Darken（变暗）：**

> * 对于每个像素位置，取**上层 HTML 元素**的**颜色**与**下层 HTML 元素**的**颜色**中**较暗**的那个**颜色**作为 **结果颜色** ；
> * 该模式倾向于保留两个**层叠的 HTML 元素**中**最深**的 **色彩** 。

* **Lighten（变亮）：**

> * 类似于** ** **Darken** ，只不过取的是**两层 HTML 元素**的**颜色**中**较亮**的那个**颜色**作为 **结果颜色** ；
> * 该模式倾向于**保留**两个**层叠的 HTML 元素**中**最浅**的 **色彩** 。

* **Color-Dodge（颜色减淡）：**

> * **上层 HTML 元素**的**颜色**根据**下层 HTML 元素**的**颜色**信息中的**亮度**调整 **自身亮度** ，使得 **结果颜色变亮** ；
> * 当**下层 HTML 元素**的**颜色较暗**时，影响 **较小** ；
> * 当**下层 HTML 元素**的**颜色接近白色**时，**上层 HTML 元素**的**颜色**会明显**变亮**甚至完全变为 **白色** 。

* **Color-Burn（颜色加深）：**

> * 与** ****Color-Dodge** 反过来，**上层 HTML 元素**的**颜色**根据**下层 HTML 元素**的**颜色信息**中的**亮度**调整 **自身亮度** ，使得 **结果颜色变暗** ；
> * 当**下层 HTML 元素**的**颜色较亮**时，影响 **较小** ；
> * 当**下层 HTML 元素**的**颜色接近黑色**时，**上层 HTML 元素**的**颜色**会明显**变暗**甚至完全变为 **黑色** 。

* **Hard-Light（强光）：**

> * 类似于** ** **Overlay** ，但作用于**下层 HTML 元素**的 **颜色** ；
> * **上层 HTML 元素**的**颜色**类似于一个 **光源** ，对**下层 HTML 元素**的**颜色**施加**明暗**影响；
> * 若**上层 HTML 元素**的**颜色**为**纯黑色**或 **纯白色** ，则会使**下层 HTML 元素**的**颜色变暗**或 **变亮** 。

* **Soft-Light（柔光）：**

> * 与** ****Hard-Light** 相似，但效果更为 **柔和** ；
> * **上层 HTML 元素**的**颜色**对**下层 HTML 元素**的**颜色**的**明暗**影响较小，产生类似**半透明**材料**覆盖**的效果。

* **Difference（差值）：**

> * 计算**上层 HTML 元素**的**颜色**与**下层 HTML 元素**的**颜色**之间的 **色差** ，结果为**两者之间**的 **对比色** ；
> * 当两层**颜色相同**时，结果为 **黑色** ；
> * 当两层**颜色互补**时，结果为 **白色** 。

* **Exclusion（排除）：**

> * 与** ****Difference** 类似，但产生的**对比度**较低；
> * **结果颜色**比** ****Difference** 模式更 **柔和** ，且不会出现**纯黑色**或 **纯白色** 。

* **Hue（色相）：**

> * 取**上层 HTML 元素**的**颜色信息**中的**色相**与**下层 HTML 元素**的**颜色信息**中的**饱和度**和 **亮度** ，生成新的 **颜色** ；
> * **下层 HTML 元素**的**颜色信息**中的**色调**被**上层 HTML 元素**的**颜色信息**中的**色调**替换，但**饱和度**和**亮度**保持不变。

* **Saturation（饱和度）：**

> * 取**下层 HTML 元素**的**颜色信息**中的**色相**与 **亮度** ，以及**上层 HTML 元素**的**颜色信息**中的 **饱和度** ，生成新的 **颜色** ；
> * **下层 HTML 元素**的**颜色信息**中的**饱和度**被**上层 HTML 元素**的**颜色信息**中的**饱和度**替换，其他属性保持不变。

* **Color（颜色）：**

> * 取**上层 HTML 元素**的**颜色信息**中的**色相**与 **饱和度** ，以及**下层 HTML 元素**的**颜色信息**中的 **亮度** ，生成新的 **颜色** ；
> * **下层 HTML 元素**的**颜色信息**中的**色调**和**饱和度**被**上层 HTML 元素**的**颜色信息**中的**色调**和**饱和度**替换，**亮度**保持不变。

* **Luminosity（亮度/明度）：**

> * 取**上层 HTML 元素**的**颜色信息**中的 **亮度** ，与**下层 HTML 元素**的**颜色信息**中的**色相**和**饱和度**结合，生成新的 **颜色** ；
> * **下层 HTML 元素**的**颜色信息**中的**亮度**被**上层 HTML 元素**的**颜色信息**中的**亮度**替换，**色调**和**饱和度**保持不变。

除了 **标准混合模式** ，还有**分离混合模式**和  **CSS Paint API 混合模式** ，这里也做一个简单的介绍：

* ***分离混合模式*** - 在 **normal、multiply、screen、darken、lighten、color-dodge、color-burn、hard-light、soft-light、difference、exclusion** 这 **11** 种标准混合模式中还可以加上 **前缀 difference** ，形成如 **difference-normal** 等 **分离混合模式** ，用于独立控制 **RGB 通道**和 **alpha 通道**的 **混合** 。

> **分离混合模式**由于其计算的**简单性**和 **效率** ，在某些情况下可能更适合**性能敏感**的应用场景。

* ***CSS Paint API混合模式*** - 一种允许开发者使用 **JavaScript** 编写**自定义绘制逻辑**来生成 **CSS 背景、边框、内容**等**图像**的 **现代 Web 技术** 。

> **CSS Paint API 混合模式**需要在**支持 CSS Paint API 的浏览器**中才能使用，是一种**特殊**的 **混合模式** ，如** plus-darker**、**plus-lighter** 等；
>
> 配合 **mix-blend-mode** 属性，**CSS Paint API** 可以实现更加 **动态** 、**灵活**且**复杂**的 **颜色混合效果** 。

**混合模式**及其**色彩**方面的知识还有很多，这里就不做过多的展开了。

咱们根据目前的知识，结合咱们的案例，感觉最适合的是 **Difference**‍ 模式。于是我们在控制文字的 **CSS** 中添加这个 **混合模式** ：

```css
h1 {
  position: absolute;
  left: 40%;
  z-index: 1;
  font-size: 9rem;
  color: #fff;
  transition: 0.5s;
  mix-blend-mode: difference;
}
```

这样，我们就得到了想要的效果：

---

# 完整源码

最后，我们还是把完整的源代码贡献给大家吧！

```html+css
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Document</title>
<style>
* {
  margin: 0;
  padding: 0;
  border: none;
  font-size: 62.5%;
}
div {
  position: relative;
  height: 500px;
  border: 5px solid #000;
  background: #fff;
  line-height: 500px;
  cursor: pointer;
}
div::before,
div::after {
  position: absolute;
  top: 0;
  bottom: 0;
  display: block;
  content: "";
}
div::before {
  left: 0;
  width: 40%;
  background: #000;
}
div::after {
  left: 40%;
  width: 0;
  height: 0;
  border-top: 250px solid transparent;
  border-right: 100px solid transparent;
  border-bottom: 250px solid #000;
  border-left: 100px solid #000;
}
h1 {
  position: absolute;
  left: 40%;
  z-index: 1;
  font-size: 9rem;
  color: #fff;
  transition: 0.5s;
  mix-blend-mode: difference;
}
div:hover > h1 {
  transform: translateX(-60%);
}
</style>
</head>
<body>
<div>
  <h1>实现文字智能适配背景</h1>
</div>
</body>
</html>
```

↓

↓

↓

若大家对**混合模式**或者**色彩**方面的知识感兴趣的，欢迎大家留言，我会在将来做成视频或者更加详细的文章进行讲解。让我们拭目以待吧！

<iframe srcdoc="<html><head><body onresize="window.parent.reeder.didLayout()"></body></html>"></iframe>
